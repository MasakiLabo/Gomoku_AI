<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>AI五目並べ - Stylish Modern</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Bloggerなどの外部サイトでスタイルが競合しないように詳細度を上げる設定
        tailwind.config = {
            important: true,
        }
    </script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com" rel="preconnect">
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- スタイル設定 -->
    <style>
        /* ベースフォント設定 */
        .app-wrapper {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }

        /* 碁盤のスタイル - モダンな木材色 */
        .board-bg {
            background-color: #E8D0A9;
            background-image: linear-gradient(to bottom right, #E8D0A9, #DEB887);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.15), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
        }
        
        /* 15路盤用のグリッド設定 */
        .grid-15 {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
        }
        
        /* 碁石のスタイル */
        .stone {
            width: 88%;
            height: 88%;
            border-radius: 50%;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 20;
        }
        /* 黒石 - 深いマットブラック */
        .stone.black {
            background: radial-gradient(circle at 30% 30%, #4a4a4a, #1a1a1a 60%, #000 100%);
            box-shadow: 2px 4px 6px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255,255,255,0.1);
        }
        /* 白石 - 陶器のようなホワイト */
        .stone.white {
            background: radial-gradient(circle at 30% 30%, #ffffff, #f0f0f0 60%, #d4d4d8 100%);
            box-shadow: 2px 4px 6px rgba(0,0,0,0.2), inset 0 -2px 4px rgba(0,0,0,0.05);
        }
        
        /* 最新の手 */
        .stone.last-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30%;
            height: 30%;
            background-color: #ef4444; /* red-500 */
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
        }

        /* グリッド線 */
        .grid-cell {
            position: relative;
        }
        .grid-cell::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: #52525b; /* zinc-600 */
            opacity: 0.8;
            z-index: 0;
        }
        .grid-cell::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            height: 100%;
            width: 1px;
            background-color: #52525b; /* zinc-600 */
            opacity: 0.8;
            z-index: 0;
        }
        
        /* 星（ドット） */
        .star-point {
            z-index: 1;
        }
        .star-point::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16%;
            height: 16%;
            max-width: 5px;
            max-height: 5px;
            background-color: #3f3f46; /* zinc-700 */
            border-radius: 50%;
        }

        /* 思考中のアニメーション */
        .thinking-dot {
            width: 8px;
            height: 8px;
            background-color: #3b82f6;
            border-radius: 50%;
            display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .thinking-dot:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        a {
          color: Orange;
          font-weight: bold;
          transition: 0.3s;
        }
        a:hover {
            color: Green;
            text-decoration: none;
        }
    </style>
</head>
<body class="m-0 p-0 bg-zinc-100 text-zinc-800 font-sans app-wrapper">

    <!-- Sticky Header -->
    <header class="sticky top-0 z-50 bg-white/95 backdrop-blur-sm border-b border-zinc-200 shadow-sm px-3 md:px-4 py-2 flex items-center justify-between">
        <div class="flex items-center gap-2 md:gap-3">
            <!-- 画像部分 (ロゴ) -->
            <div class="h-9 w-9 md:h-10 md:w-10 bg-zinc-100 rounded-lg flex items-center justify-center overflow-hidden shadow-inner border border-zinc-100 flex-shrink-0">
                <!-- プレースホルダー画像: 画像ファイルを指定する場合はsrcを変更してください -->
                <img src="https://placehold.co/100x100/3f3f46/ffffff?text=G" alt="Logo" class="w-full h-full object-cover">
            </div>
            <div>
                <h1 class="text-sm md:text-base font-bold text-zinc-900 leading-tight whitespace-nowrap" data-t="appTitle">Gomoku AI</h1>
                <p class="text-[10px] text-zinc-400 font-medium tracking-wide hidden md:block" data-t="subTitle">STRATEGY BOARD GAME</p>
            </div>
        </div>
        
        <div class="flex items-center gap-2">
            <!-- Language Switcher -->
            <div class="flex bg-zinc-100 rounded-lg p-1 flex-shrink-0">
                <button class="px-2 py-1 text-[10px] font-bold rounded bg-white text-zinc-800 shadow-sm transition-all" id="langJaBtn">JP</button>
                <button class="px-2 py-1 text-[10px] font-medium text-zinc-400 hover:text-zinc-600 transition-all" id="langEnBtn">EN</button>
            </div>

            <!-- About Toggle Button (テキスト付きに変更) -->
            <button id="headerAboutBtn" class="flex items-center gap-1 px-3 py-1.5 text-xs font-bold text-zinc-600 hover:text-zinc-900 hover:bg-zinc-50 rounded-lg transition-colors border border-zinc-200 bg-white shadow-sm whitespace-nowrap" title="About">
                <svg fill="none" height="14" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="14" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10"></circle><line x1="12" x2="12" y1="16" y2="12"></line><line x1="12" x2="12.01" y1="8" y2="8"></line></svg>
                <span data-t="aboutBtn">このツールについて</span>
            </button>
        </div>
    </header>

    <!-- (1) このツールについて (ドロップダウンパネル) -->
    <div id="aboutPanel" class="hidden bg-white border-b border-zinc-200 p-6 shadow-inner transition-all duration-300">
        <div class="max-w-5xl mx-auto flex flex-col md:flex-row gap-6 items-start">
            <div class="flex-1">
                <h3 class="font-bold text-lg mb-2 text-zinc-800 flex items-center gap-2">
                    <span data-t="aboutTitle">このツールについて</span>
                </h3>
                <p class="text-zinc-600 text-sm leading-relaxed mb-3">
                    <span data-t="aboutDesc">AIへのプロンプト生成機能と <strong>CPU対戦機能</strong>を搭載したWebアプリです<br />
                    デザインを一新し より対局に集中できるモダンなインターフェースになりました</span>
                </p>
               　 <div class="flex gap-2 flex-wrap text-xs font-medium text-zinc-500">
                    <span class="px-2 py-1 border border-zinc-300 rounded-md" data-t="levelEasyTag">初級: 気まぐれ</span>
                    <span class="px-2 py-1 border border-zinc-300 rounded-md" data-t="levelNormalTag">中級: リーチ阻止</span>
                    <span class="px-2 py-1 border border-zinc-300 rounded-md" data-t="levelHardTag">上級: 攻防バランス</span>
                </div>
            </div>
            <button id="closeAboutBtn" class="self-end md:self-start text-xs text-zinc-400 hover:text-zinc-600 underline">Close</button>
        </div>
    </div>

    <!-- 全体を包むラッパー (コンテンツ) -->
    <div class="w-full flex justify-center py-4 md:py-6 px-4">
        <!-- メイングリッドコンテナ -->
        <div id="gomoku-app" class="w-full max-w-5xl grid grid-cols-1 md:grid-cols-[1fr_20rem] gap-4 md:gap-6 items-start">

            <!-- (2) 対戦設定 & 情報パネル -->
            <!-- Mobile: Order 2, PC: Right Col (Row 1) -->
            <div class="order-2 md:order-none md:col-start-2 md:row-start-1 flex flex-col gap-4">
                
                <!-- 手番情報 & リセット -->
                <div class="bg-white p-5 rounded-2xl shadow-sm border border-zinc-200">
                    <div class="flex justify-between items-center mb-4">
                         <span class="text-xs font-bold text-zinc-400 tracking-wider">GAME INFO</span>
                        <button class="text-xs bg-zinc-50 border border-zinc-200 hover:bg-zinc-100 text-zinc-600 px-3 py-1.5 rounded-lg transition font-medium" data-t="resetBtn" id="resetBtn">リセット</button>
                    </div>

                    <div class="w-full p-3 rounded-xl bg-zinc-900 text-white shadow-md flex items-center justify-between transition-all duration-300" id="turnIndicator">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-zinc-900 border-2 border-white/80 shadow-sm" id="turnIcon"></div>
                            <span class="text-[10px] font-medium opacity-70 tracking-wider" data-t="turnLabel">TURN</span>
                        </div>
                        <span class="text-base font-bold tracking-widest" id="turnText">BLACK</span>
                    </div>
                </div>

                <!-- 設定エリア -->
                <div class="bg-white rounded-2xl p-5 border border-zinc-200 shadow-sm">
                    <h2 class="font-bold text-zinc-700 mb-4 flex items-center gap-2 text-sm">
                        <svg class="text-zinc-500" fill="none" height="18" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" stroke="currentColor" viewbox="0 0 24 24" width="18" xmlns="http://www.w3.org/2000/svg"><path d="M12 2a10 10 0 1 0 10 10H12V2z"><path d="M12 12 2.1 12a10.1 10.1 0 0 0 9.9 9.9 10 10 0 0 0 10-10"></path></path></svg>
                        <span data-t="settingsTitle">対戦設定</span>
                    </h2>
                    
                    <div class="flex flex-col gap-4">
                        <label class="relative flex items-center justify-between cursor-pointer group">
                            <span class="text-sm font-bold text-zinc-700 group-hover:text-zinc-900 transition" data-t="vsCpuLabel">VS CPU Mode</span>
                            <input class="sr-only peer" id="cpuModeToggle" type="checkbox" />
                            <div class="relative w-11 h-6 bg-zinc-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-zinc-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-zinc-900"></div>
                        </label>

                        <div class="opacity-50 pointer-events-none transition-all duration-300 flex flex-col gap-4 pl-2 border-l-2 border-zinc-100" id="cpuSettings">
                            <!-- 難易度 -->
                            <div>
                                <label class="block text-xs font-bold text-zinc-400 mb-1.5 uppercase tracking-wider" data-t="difficultyLabel">Difficulty</label>
                                <div class="relative">
                                    <select class="w-full appearance-none bg-zinc-50 border border-zinc-200 text-zinc-700 text-sm rounded-lg focus:ring-zinc-500 focus:border-zinc-500 block p-2.5 font-medium" id="cpuLevel">
                                        <option data-t="level1Option" value="1">LEVEL 1 (Easy)</option>
                                        <option data-t="level2Option" selected="" value="2">LEVEL 2 (Normal)</option>
                                        <option data-t="level3Option" value="3">LEVEL 3 (Hard)</option>
                                    </select>
                                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-zinc-500">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewbox="0 0 24 24"><path d="M19 9l-7 7-7-7" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path></svg>
                                    </div>
                                </div>
                            </div>

                            <!-- 手番選択 -->
                            <div>
                                <label class="block text-xs font-bold text-zinc-400 mb-1.5 uppercase tracking-wider" data-t="cpuTurnLabel">CPU Turn</label>
                                <div class="grid grid-cols-2 gap-2">
                                    <label class="cursor-pointer">
                                        <input checked="" class="peer sr-only" name="cpuTurn" type="radio" value="2" />
                                        <div class="text-center text-sm py-2 rounded-lg border border-zinc-200 text-zinc-600 bg-white peer-checked:bg-zinc-800 peer-checked:text-white peer-checked:border-zinc-800 transition" data-t="roleWhite">
                                            後手 (White)
                                        </div>
                                    </label>
                                    <label class="cursor-pointer">
                                        <input class="peer sr-only" name="cpuTurn" type="radio" value="1" />
                                        <div class="text-center text-sm py-2 rounded-lg border border-zinc-200 text-zinc-600 bg-white peer-checked:bg-zinc-800 peer-checked:text-white peer-checked:border-zinc-800 transition" data-t="roleBlack">
                                            先手 (Black)
                                        </div>
                                    </label>
                                </div>
                            </div>

                            <!-- 対局開始ボタン -->
                            <button class="hidden w-full bg-zinc-800 hover:bg-zinc-700 text-white py-2 rounded-lg font-bold text-sm transition shadow-sm mt-2 flex items-center justify-center gap-2" id="cpuStartBtn">
                                <svg fill="none" height="16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" stroke="currentColor" viewbox="0 0 24 24" width="16" xmlns="http://www.w3.org/2000/svg"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                                <span data-t="startBtn">対局開始</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- (3), (4), (5) 左カラムのメインコンテンツグループ -->
            <!-- Mobile: Order 3, PC: Left Col (Row 1 span 2) -->
            <!-- ここで gap-2 (8px) を指定して縦並びの間隔を詰めています -->
            <div class="order-3 md:order-none md:col-start-1 md:row-start-1 md:row-span-2 flex flex-col gap-2">
                
                <!-- (3) 石をおく操作部分 -->
                <div class="bg-white p-4 rounded-2xl shadow-sm border border-zinc-200">
                    <div class="flex gap-3 w-full">
                        <div class="relative flex-1">
                            <input class="w-full pl-4 pr-4 py-3 rounded-xl border border-zinc-300 shadow-sm uppercase focus:outline-none focus:ring-2 focus:ring-zinc-500 focus:border-transparent text-zinc-800 font-mono tracking-wider transition" id="coordInput" placeholder="H8" type="text" />
                            <div class="absolute inset-y-0 right-3 flex items-center pointer-events-none text-zinc-400 text-xs">
                                COORD
                            </div>
                        </div>
                        <button class="bg-zinc-900 hover:bg-zinc-800 text-white px-6 py-3 rounded-xl font-bold shadow-md transition transform active:scale-95 flex items-center gap-2 whitespace-nowrap" id="submitCoordBtn">
                            <span data-t="placeStoneBtn">着手</span>
                            <svg fill="none" height="16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" stroke="currentColor" viewbox="0 0 24 24" width="16" xmlns="http://www.w3.org/2000/svg"><line x1="5" x2="19" y1="12" y2="12"><polyline points="12 5 19 12 12 19"></polyline></line></svg>
                        </button>
                    </div>
                </div>

                <!-- (4) AIへのプロンプト -->
                 <div class="bg-white p-4 rounded-2xl shadow-sm border border-zinc-200">
                    <h2 class="font-bold text-zinc-700 mb-2 flex items-center gap-2 text-sm">
                        <svg fill="none" height="16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" stroke="currentColor" viewbox="0 0 24 24" width="16" xmlns="http://www.w3.org/2000/svg"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
                        <span data-t="promptTitle">AI Prompt</span>
                    </h2>
                    <div class="relative group">
                        <textarea class="w-full h-24 p-3 text-[10px] leading-relaxed font-mono border border-zinc-200 rounded-xl bg-zinc-50 text-zinc-600 focus:outline-none focus:ring-1 focus:ring-zinc-400 resize-none transition" id="aiPrompt" readonly=""></textarea>
                        <button class="absolute bottom-2 right-2 bg-white border border-zinc-200 hover:bg-zinc-50 text-zinc-600 p-1.5 rounded-lg transition shadow-sm" id="copyBtn" title="Copy to Clipboard">
                            <svg fill="none" height="16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" stroke="currentColor" viewbox="0 0 24 24" width="16" xmlns="http://www.w3.org/2000/svg"><rect height="14" rx="2" ry="2" width="14" x="8" y="8"><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></rect></svg>
                        </button>
                    </div>
                </div>

                <!-- (5) 盤面 -->
                <!-- w-full で親要素幅いっぱいにし、メニューブロックと幅を揃えています -->
                <div class="relative w-full bg-white p-1 md:p-2 rounded-xl shadow-2xl border border-zinc-200">
                    <!-- 座標ラベル (上) -->
                    <div class="flex pl-4 md:pl-6 mb-1 text-[10px] md:text-xs font-mono text-zinc-400 select-none">
                        <div class="flex w-full justify-around font-medium" id="colLabels"></div>
                    </div>
                    
                    <div class="flex">
                        <!-- 座標ラベル (左) -->
                        <div class="flex flex-col justify-around mr-1 text-[10px] md:text-xs font-mono text-zinc-400 w-3 md:w-5 text-right select-none h-auto aspect-square font-medium" id="rowLabels"></div>
                        
                        <!-- 碁盤 -->
                        <div class="board-bg grid-15 w-full aspect-square rounded-sm relative cursor-pointer ring-1 ring-zinc-900/5" id="board">
                            <!-- セルはJSで生成 -->
                        </div>
                    </div>

                    <!-- CPU思考中オーバーレイ -->
                    <div class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-40 bg-zinc-900/90 text-white px-6 py-3 rounded-full shadow-2xl flex items-center gap-3 backdrop-blur-sm" id="cpuThinking">
                        <div class="flex gap-1">
                            <div class="thinking-dot"></div>
                            <div class="thinking-dot"></div>
                            <div class="thinking-dot"></div>
                        </div>
                        <span class="font-bold text-sm tracking-wide" data-t="cpuThinking">CPU THINKING</span>
                    </div>

                    <!-- 勝利メッセージ -->
                    <div class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white/95 backdrop-blur-md p-8 rounded-3xl shadow-2xl border border-zinc-200 text-center z-30 w-72 md:w-80" id="winMessage">
                        <div class="w-16 h-16 bg-yellow-100 text-yellow-600 rounded-full flex items-center justify-center mx-auto mb-4">
                            <svg fill="none" height="32" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" stroke="currentColor" viewbox="0 0 24 24" width="32" xmlns="http://www.w3.org/2000/svg"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"><path d="M4 22h16"><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path></path></path></path></path></path></svg>
                        </div>
                        <h2 class="text-2xl font-bold mb-2 text-zinc-900 tracking-tight" data-t="gameSet">GAME SET</h2>
                        <p class="text-lg font-bold text-zinc-600 mb-8" id="winnerText"></p>
                        <button class="w-full bg-zinc-900 text-white py-3 rounded-xl hover:bg-zinc-800 font-bold transition shadow-lg transform active:scale-95" data-t="rematchBtn" id="rematchBtn">もう一度対戦</button>
                    </div>
                </div>
            </div>

            <!-- (6) 棋譜 -->
            <!-- Mobile: Order 4, PC: Right Col (Row 2) -->
            <div class="order-4 md:order-none md:col-start-2 md:row-start-2">
                <div class="bg-white p-5 rounded-2xl shadow-sm border border-zinc-200">
                    <h3 class="font-bold text-zinc-700 mb-3 text-sm flex items-center justify-between">
                        <span data-t="historyTitle">History</span>
                        <span class="text-xs bg-zinc-100 text-zinc-500 px-2 py-0.5 rounded-full" id="moveCount">0 moves</span>
                    </h3>
                    <div class="h-64 overflow-y-auto border border-zinc-100 rounded-xl bg-white p-1 text-sm font-mono shadow-inner scroll-smooth" id="moveHistory">
                        <!-- 履歴 -->
                    </div>
                </div>
            </div>

        </div>
    </div>

    <!-- カスタムモーダル -->
    <div class="hidden absolute inset-0 bg-zinc-900/40 backdrop-blur-sm z-50 flex items-center justify-center opacity-0 transition-opacity duration-200" id="customModal">
        <div class="bg-white p-6 rounded-2xl shadow-2xl max-w-sm w-full mx-4 transform scale-95 transition-transform duration-200 border border-zinc-100">
            <h3 class="text-lg font-bold mb-2 text-zinc-900" data-t="modalConfirmTitle" id="modalTitle">確認</h3>
            <p class="text-zinc-600 mb-6 text-sm leading-relaxed" id="modalMessage">メッセージ</p>
            <div class="flex justify-end gap-3">
                <button class="px-4 py-2 text-zinc-500 hover:bg-zinc-50 hover:text-zinc-800 rounded-lg font-medium transition text-sm" data-t="modalCancel" id="modalCancelBtn">キャンセル</button>
                <button class="px-5 py-2 bg-zinc-900 text-white rounded-lg hover:bg-zinc-800 font-bold shadow-md transition transform active:scale-95 text-sm" data-t="modalOk" id="modalOkBtn">OK</button>
            </div>
        </div>
    </div>

<script>
{
    // グローバル汚染を防ぐためにブロックで囲む
    const BOARD_SIZE = 15;
    const COL_LABELS = "ABCDEFGHIJKLMNO".split('');
    
    // 言語設定
    let currentLang = 'ja'; // 'ja' or 'en'
    
    // 翻訳辞書
    const translations = {
        ja: {
            appTitle: "AI五目並べ",
            subTitle: "STRATEGY BOARD GAME",
            aboutBtn: "このツールについて",
            aboutTitle: "このツールについて",
            aboutDesc: "AIへのプロンプト生成機能と <strong>CPU対戦機能</strong>を搭載したWebアプリです<br>デザインを一新し より対局に集中できるモダンなインターフェースになりました",
            levelEasyTag: "初級: 気まぐれ",
            levelNormalTag: "中級: リーチ阻止",
            levelHardTag: "上級: 攻防バランス",
            resetBtn: "リセット",
            startBtn: "対局開始",
            placeStoneBtn: "石を置く",
            cpuThinking: "CPU思考中",
            gameSet: "勝負あり！",
            rematchBtn: "もう一度対戦",
            turnLabel: "手番",
            turnBlack: "黒の番",
            turnWhite: "白の番",
            settingsTitle: "対戦設定",
            vsCpuLabel: "VS CPUモード",
            difficultyLabel: "CPUの強さ",
            level1Option: "レベル 1 (初級)",
            level2Option: "レベル 2 (中級)",
            level3Option: "レベル 3 (上級)",
            cpuTurnLabel: "CPUの手番",
            roleWhite: "後手 (白)",
            roleBlack: "先手 (黒)",
            historyTitle: "棋譜",
            promptTitle: "AIへのプロンプト",
            modalConfirmTitle: "確認",
            modalErrorTitle: "エラー",
            modalCancel: "キャンセル",
            modalOk: "実行",
            modalOkAlert: "OK",
            msgResetConfirm: "盤面をリセットしますか\n設定変更も適用されます",
            msgStartConfirm: "この設定で対局を開始しますか\n現在の盤面はリセットされます",
            msgCoordError: "そこには既に石があります",
            msgCoordRangeError: "座標が範囲外です",
            msgFormatError: "座標の形式が正しくありません (例: H8)",
            winSuffix: "の勝ちです",
            blackName: "黒 (Black)",
            whiteName: "白 (White)"
        },
        en: {
            appTitle: "Gomoku AI",
            subTitle: "STRATEGY BOARD GAME",
            aboutBtn: "About",
            aboutTitle: "About This Tool",
            aboutDesc: "A web app featuring <strong>CPU Battle Mode</strong> and AI Prompt Generation.<br>Redesigned with a modern interface to help you focus on the game.",
            levelEasyTag: "Easy: Random",
            levelNormalTag: "Normal: Defensive",
            levelHardTag: "Hard: Balanced",
            resetBtn: "Reset",
            startBtn: "Start Game",
            placeStoneBtn: "Place",
            cpuThinking: "CPU THINKING",
            gameSet: "GAME SET",
            rematchBtn: "Play Again",
            turnLabel: "TURN",
            turnBlack: "BLACK",
            turnWhite: "WHITE",
            settingsTitle: "Game Settings",
            vsCpuLabel: "VS CPU Mode",
            difficultyLabel: "Difficulty",
            level1Option: "LEVEL 1 (Easy)",
            level2Option: "LEVEL 2 (Normal)",
            level3Option: "LEVEL 3 (Hard)",
            cpuTurnLabel: "CPU Turn",
            roleWhite: "White (2nd)",
            roleBlack: "Black (1st)",
            historyTitle: "History",
            promptTitle: "AI Prompt",
            modalConfirmTitle: "Confirm",
            modalErrorTitle: "Error",
            modalCancel: "Cancel",
            modalOk: "Execute",
            modalOkAlert: "OK",
            msgResetConfirm: "Are you sure you want to reset the board?\nSettings will be applied.",
            msgStartConfirm: "Start game with these settings?\n(Current board will be reset)",
            msgCoordError: "There is already a stone there!",
            msgCoordRangeError: "Coordinates out of bounds.",
            msgFormatError: "Invalid coordinate format (e.g. H8)",
            winSuffix: " WINS!",
            blackName: "BLACK",
            whiteName: "WHITE"
        }
    };

    // 初期化時にゼロ埋めされた盤面配列を作成
    let board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0)); 
    let currentPlayer = 1; 
    let moves = [];
    let isGameOver = false;

    // CPU設定
    let isCpuMode = false;
    let cpuLevel = 2;
    let cpuPlayer = 2; // デフォルトは白(後手)
    let isCpuThinking = false;

    // Element取得
    const boardEl = document.getElementById('board');
    const colLabelsEl = document.getElementById('colLabels');
    const rowLabelsEl = document.getElementById('rowLabels');
    const turnIndicator = document.getElementById('turnIndicator');
    const turnIcon = document.getElementById('turnIcon');
    const turnText = document.getElementById('turnText');
    const historyEl = document.getElementById('moveHistory');
    const moveCountEl = document.getElementById('moveCount');
    const promptEl = document.getElementById('aiPrompt');
    const winMessageEl = document.getElementById('winMessage');
    const winnerTextEl = document.getElementById('winnerText');
    const cpuThinkingEl = document.getElementById('cpuThinking');
    
    // UI Elements
    const cpuToggleEl = document.getElementById('cpuModeToggle');
    const cpuLevelEl = document.getElementById('cpuLevel');
    const cpuSettingsEl = document.getElementById('cpuSettings');
    const cpuStartBtn = document.getElementById('cpuStartBtn');
    
    // Language Buttons
    const langJaBtn = document.getElementById('langJaBtn');
    const langEnBtn = document.getElementById('langEnBtn');

    // About Section Toggle Elements
    const headerAboutBtn = document.getElementById('headerAboutBtn');
    const aboutPanel = document.getElementById('aboutPanel');
    const closeAboutBtn = document.getElementById('closeAboutBtn');
    let isAboutExpanded = false;

    // About Section Toggle Logic
    function toggleAbout() {
        isAboutExpanded = !isAboutExpanded;
        if (isAboutExpanded) {
            aboutPanel.classList.remove('hidden');
        } else {
            aboutPanel.classList.add('hidden');
        }
    }

    headerAboutBtn.onclick = toggleAbout;
    closeAboutBtn.onclick = toggleAbout;

    // Buttons
    document.getElementById('resetBtn').onclick = confirmReset;
    document.getElementById('rematchBtn').onclick = confirmReset;
    document.getElementById('submitCoordBtn').onclick = submitCoord;
    document.getElementById('copyBtn').onclick = copyPrompt;
    document.getElementById('cpuStartBtn').onclick = confirmStart;
    
    // Radio buttons for Turn
    const turnRadios = document.querySelectorAll('input[name="cpuTurn"]');
    turnRadios.forEach(radio => {
        radio.addEventListener('change', updateStartBtnState);
    });

    // Language Handlers
    function setLanguage(lang) {
        currentLang = lang;
        
        // Update Buttons Style
        if (lang === 'ja') {
            // JA Active
            langJaBtn.classList.add('bg-white', 'text-zinc-800', 'shadow-sm', 'font-bold');
            langJaBtn.classList.remove('text-zinc-400', 'font-medium');
            
            // EN Inactive
            langEnBtn.classList.add('text-zinc-400', 'font-medium');
            langEnBtn.classList.remove('bg-white', 'text-zinc-800', 'shadow-sm', 'font-bold');
        } else {
            // EN Active
            langEnBtn.classList.add('bg-white', 'text-zinc-800', 'shadow-sm', 'font-bold');
            langEnBtn.classList.remove('text-zinc-400', 'font-medium');
            
            // JA Inactive
            langJaBtn.classList.add('text-zinc-400', 'font-medium');
            langJaBtn.classList.remove('bg-white', 'text-zinc-800', 'shadow-sm', 'font-bold');
        }

        // Apply translations
        const t = translations[lang];
        document.querySelectorAll('[data-t]').forEach(el => {
            const key = el.getAttribute('data-t');
            if (t[key]) {
                el.innerHTML = t[key];
            }
        });

        updateUI(); 
        generatePrompt(); 
    }

    // Stop propagation for language buttons to prevent toggle when clicking them
    langJaBtn.onclick = (e) => {
        e.stopPropagation();
        setLanguage('ja');
    };
    langEnBtn.onclick = (e) => {
        e.stopPropagation();
        setLanguage('en');
    };
    
    // CPU UI Handlers
    cpuToggleEl.addEventListener('change', (e) => {
        isCpuMode = e.target.checked;
        if (isCpuMode) {
            cpuSettingsEl.classList.remove('opacity-50', 'pointer-events-none');
            updateStartBtnState();
        } else {
            cpuSettingsEl.classList.add('opacity-50', 'pointer-events-none');
            // CPUオフ時は開始ボタンを隠す
            cpuStartBtn.classList.add('hidden');
        }
    });
    
    function updateStartBtnState() {
        if (!isCpuMode) {
            cpuStartBtn.classList.add('hidden');
            return;
        }
        
        const turnVal = document.querySelector('input[name="cpuTurn"]:checked').value;
        const selectedCpuPlayer = parseInt(turnVal);

        cpuStartBtn.classList.remove('hidden');
    }
    
    // Modal Elements
    const modalEl = document.getElementById('customModal');
    const modalTitleEl = document.getElementById('modalTitle');
    const modalMessageEl = document.getElementById('modalMessage');
    const modalOkBtn = document.getElementById('modalOkBtn');
    const modalCancelBtn = document.getElementById('modalCancelBtn');

    function initGame() {
        // 盤面リセット
        for(let r=0; r<BOARD_SIZE; r++) {
            for(let c=0; c<BOARD_SIZE; c++) {
                board[r][c] = 0;
            }
        }

        currentPlayer = 1;
        moves = [];
        isGameOver = false;
        isCpuThinking = false;
        winMessageEl.classList.add('hidden');
        cpuThinkingEl.classList.add('hidden');
        
        // 設定を反映
        isCpuMode = cpuToggleEl.checked;
        cpuLevel = parseInt(cpuLevelEl.value);
        
        // CPUの手番設定を取得
        const turnVal = document.querySelector('input[name="cpuTurn"]:checked').value;
        cpuPlayer = parseInt(turnVal);

        closeModal();
        
        renderGrid();
        updateUI();
        generatePrompt();

        // CPUが先手(黒)でCPUモードの場合、初手を打つ
        if (isCpuMode && currentPlayer === cpuPlayer) {
            triggerCpuMove();
        }
    }

    function renderGrid() {
        boardEl.innerHTML = '';
        colLabelsEl.innerHTML = '';
        rowLabelsEl.innerHTML = '';

        // Labels
        COL_LABELS.forEach(label => {
            const div = document.createElement('div');
            div.textContent = label;
            div.className = 'flex-1 text-center flex items-end justify-center pb-1 text-zinc-500';
            colLabelsEl.appendChild(div);
        });
        for (let i = 1; i <= BOARD_SIZE; i++) {
            const div = document.createElement('div');
            div.textContent = i;
            div.className = 'flex-1 flex items-center justify-end pr-1 text-zinc-500';
            rowLabelsEl.appendChild(div);
        }

        // Cells
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell w-full h-full flex items-center justify-center relative z-10';
                cell.dataset.r = r;
                cell.dataset.c = c;
                
                // 星
                if (
                    (r === 3 && c === 3) || (r === 3 && c === 11) ||
                    (r === 7 && c === 7) ||
                    (r === 11 && c === 3) || (r === 11 && c === 11)
                ) {
                    const star = document.createElement('div');
                    star.className = 'star-point w-full h-full absolute pointer-events-none';
                    cell.appendChild(star);
                }

                cell.addEventListener('click', () => handleCellClick(r, c));
                boardEl.appendChild(cell);
            }
        }
    }

    function handleCellClick(r, c) {
        if (isGameOver || board[r][c] !== 0 || isCpuThinking) return;
        
        // 自分の手番でなければ無視（CPU思考中など）
        if (isCpuMode && currentPlayer === cpuPlayer) return;

        // 人間の手
        makeMove(r, c);

        // CPUモードならCPUの手番へ
        if (!isGameOver && isCpuMode && currentPlayer === cpuPlayer) {
            triggerCpuMove();
        }
    }

    function triggerCpuMove() {
        isCpuThinking = true;
        cpuThinkingEl.classList.remove('hidden');
        
        // 少し遅延させて「考え中」っぽくする
        setTimeout(() => {
            const move = calculateBestMove();
            if (move) {
                makeMove(move.r, move.c);
            }
            isCpuThinking = false;
            cpuThinkingEl.classList.add('hidden');
        }, 600);
    }

    // ==========================================
    // CPU Logic (Simple Heuristic)
    // ==========================================
    function calculateBestMove() {
        if (moves.length === 0) {
            return {r: 7, c: 7};
        }

        let candidates = [];
        
        for(let r=0; r<BOARD_SIZE; r++) {
            for(let c=0; c<BOARD_SIZE; c++) {
                if(board[r][c] === 0) {
                    if (hasNeighbor(r, c, 2)) {
                        const score = evaluatePosition(r, c, cpuPlayer, cpuLevel);
                        candidates.push({r, c, score});
                    }
                }
            }
        }

        candidates.sort((a, b) => b.score - a.score);

        if (candidates.length === 0) return null;

        if (cpuLevel === 1) {
            const range = Math.max(1, Math.floor(candidates.length * 0.2));
            const idx = Math.floor(Math.random() * range);
            return candidates[idx];
        } else if (cpuLevel === 2) {
            if (candidates[0].score >= 10000) return candidates[0];
            const idx = Math.random() < 0.8 ? 0 : Math.floor(Math.random() * Math.min(3, candidates.length));
            return candidates[idx];
        } else {
            return candidates[0];
        }
    }

    function hasNeighbor(r, c, dist) {
        for(let dr = -dist; dr <= dist; dr++) {
            for(let dc = -dist; dc <= dist; dc++) {
                if (dr===0 && dc===0) continue;
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                    if (board[nr][nc] !== 0) return true;
                }
            }
        }
        return false;
    }

    function evaluatePosition(r, c, player, level) {
        const opponent = player === 1 ? 2 : 1;
        let attackScore = evaluateLines(r, c, player);
        let defenseScore = evaluateLines(r, c, opponent);
        
        if (attackScore >= 100000) return 200000;
        if (defenseScore >= 100000) return 150000;

        if (level === 1) {
            return attackScore + (defenseScore * 0.5) + Math.random() * 10;
        } else if (level === 2) {
            return attackScore + defenseScore + Math.random() * 50;
        } else {
            return attackScore * 1.1 + defenseScore;
        }
    }

    function evaluateLines(r, c, color) {
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
        let totalScore = 0;

        for (let [dr, dc] of directions) {
            let count = 1;
            let openEnds = 0;
            
            let i = 1;
            let blocked1 = false;
            while (true) {
                const nr = r + dr * i, nc = c + dc * i;
                if (!isValid(nr, nc)) { blocked1 = true; break; }
                if (board[nr][nc] === color) {
                    count++;
                } else if (board[nr][nc] === 0) {
                    openEnds++;
                    break;
                } else {
                    blocked1 = true;
                    break;
                }
                i++;
            }

            let j = 1;
            let blocked2 = false;
            while (true) {
                const nr = r - dr * j, nc = c - dc * j;
                if (!isValid(nr, nc)) { blocked2 = true; break; }
                if (board[nr][nc] === color) {
                    count++;
                } else if (board[nr][nc] === 0) {
                    openEnds++;
                    break;
                } else {
                    blocked2 = true;
                    break;
                }
                j++;
            }
            
            if (count >= 5) {
                totalScore += 100000;
            } else if (count === 4) {
                if (openEnds >= 1) totalScore += 10000;
                if (openEnds === 2) totalScore += 20000;
            } else if (count === 3) {
                if (openEnds === 2) totalScore += 5000;
                if (openEnds === 1) totalScore += 500;
            } else if (count === 2) {
                if (openEnds === 2) totalScore += 100;
            } else if (count === 1) {
                totalScore += 10;
            }
        }
        return totalScore;
    }

    function isValid(r, c) {
        return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE;
    }


    // ==========================================
    // UI Functions
    // ==========================================

    function submitCoord() {
        if (isGameOver || isCpuThinking) return;
        if (isCpuMode && currentPlayer === cpuPlayer) return;

        const input = document.getElementById('coordInput');
        const val = input.value.trim().toUpperCase();
        const t = translations[currentLang];
        
        if (!val) return;

        const match = val.match(/([A-O])([0-9]+)/) || val.match(/([0-9]+)([A-O])/);
        
        if (match) {
            let colStr, rowStr;
            if (isNaN(match[1])) {
                colStr = match[1];
                rowStr = match[2];
            } else {
                rowStr = match[1];
                colStr = match[2];
            }

            const c = COL_LABELS.indexOf(colStr);
            const r = parseInt(rowStr) - 1;

            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                if (board[r][c] === 0) {
                    makeMove(r, c);
                    input.value = '';
                    
                    if (!isGameOver && isCpuMode && currentPlayer === cpuPlayer) {
                        triggerCpuMove();
                    }
                } else {
                    showAlert(t.modalErrorTitle, t.msgCoordError);
                }
            } else {
                showAlert(t.modalErrorTitle, t.msgCoordRangeError);
            }
        } else {
            showAlert(t.modalErrorTitle, t.msgFormatError);
        }
    }

    function makeMove(r, c) {
        board[r][c] = currentPlayer;
        moves.push({r, c, player: currentPlayer});
        
        if (checkWin(r, c, currentPlayer)) {
            isGameOver = true;
            endGame(currentPlayer);
        } else {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
        }

        renderStones();
        updateUI();
        generatePrompt();
    }

    function renderStones() {
        const cells = boardEl.querySelectorAll('.grid-cell');
        cells.forEach(cell => {
            const existingStone = cell.querySelector('.stone');
            if (existingStone) existingStone.remove();
            
            const r = parseInt(cell.dataset.r);
            const c = parseInt(cell.dataset.c);

            if (board[r][c] !== 0) {
                const stone = document.createElement('div');
                stone.className = `stone ${board[r][c] === 1 ? 'black' : 'white'} relative z-20`;
                
                const lastMove = moves[moves.length - 1];
                if (lastMove && lastMove.r === r && lastMove.c === c) {
                    stone.classList.add('last-move');
                }

                cell.appendChild(stone);
            }
        });
    }

    function checkWin(r, c, player) {
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
        for (let [dr, dc] of directions) {
            let count = 1;
            let i = 1;
            while (true) {
                const nr = r + dr * i, nc = c + dc * i;
                if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE || board[nr][nc] !== player) break;
                count++; i++;
            }
            i = 1;
            while (true) {
                const nr = r - dr * i, nc = c - dc * i;
                if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE || board[nr][nc] !== player) break;
                count++; i++;
            }
            if (count >= 5) return true;
        }
        return false;
    }

    function endGame(winner) {
        const t = translations[currentLang];
        const name = winner === 1 ? t.blackName : t.whiteName;
        winnerTextEl.textContent = `${name} ${t.winSuffix}`;
        winMessageEl.classList.remove('hidden');
        
        generatePrompt(); // プロンプトも勝敗メッセージ付きで更新
    }

    function updateUI() {
        const t = translations[currentLang];

        if (currentPlayer === 1) {
            turnIcon.className = "w-3 h-3 rounded-full bg-black border-2 border-white shadow-sm";
            turnText.textContent = t.turnBlack;
            turnIndicator.className = "w-full p-3 rounded-xl bg-zinc-900 text-white shadow-md flex items-center justify-between transition-all duration-300";
        } else {
            turnIcon.className = "w-3 h-3 rounded-full bg-white border-2 border-zinc-300 shadow-sm";
            turnText.textContent = t.turnWhite;
            turnIndicator.className = "w-full p-3 rounded-xl bg-white text-zinc-900 border border-zinc-200 shadow-sm flex items-center justify-between transition-all duration-300";
        }

        historyEl.innerHTML = '';
        moves.forEach((m, idx) => {
            const div = document.createElement('div');
            const playerStr = m.player === 1 ? "B" : "W";
            const coord = `${COL_LABELS[m.c]}${m.r + 1}`;
            div.innerHTML = `<span class="inline-block w-6 text-zinc-400 text-right mr-2">${idx + 1}.</span> <span class="font-bold ${m.player === 1 ? 'text-zinc-800' : 'text-zinc-500'}">${playerStr}</span> <span class="text-zinc-600">${coord}</span>`;
            div.className = "py-1.5 px-2 rounded hover:bg-zinc-50 flex items-center border-b border-dashed border-zinc-100 last:border-0";
            if (idx === moves.length - 1) div.className += " bg-blue-50/50 border-l-2 border-l-blue-500";
            historyEl.appendChild(div);
        });
        historyEl.scrollTop = historyEl.scrollHeight;
        moveCountEl.textContent = `${moves.length} moves`;
    }

    function generatePrompt() {
        // 多言語対応プロンプト
        const t = translations[currentLang];
        const playerStr = currentPlayer === 1 ? t.roleBlack : t.roleWhite;
        const opponentStr = currentPlayer === 1 ? (currentLang === 'ja' ? '白' : 'White') : (currentLang === 'ja' ? '黒' : 'Black');
        const lastMove = moves.length > 0 ? moves[moves.length - 1] : null;
        
        let text = "";
        
        if (currentLang === 'ja') {
            // 日本語プロンプト
            if (isGameOver) {
                const winner = currentPlayer === 1 ? 2 : 1; // 直前の手番プレイヤーが勝者
                const name = winner === 1 ? "黒" : "白";
                const lastMoveCoord = lastMove ? `${COL_LABELS[lastMove.c]}${lastMove.r + 1}` : "";
                text = `ゲーム終了！\n${name}が${lastMoveCoord}に置いて勝利しました。\nお疲れ様でした。感想戦を行いましょう。`;
            } else {
                text = `五目並べ（15x15盤）の対戦中です。\nあなたは「${playerStr}」です。\n`;
                if (lastMove) {
                    const coord = `${COL_LABELS[lastMove.c]}${lastMove.r + 1}`;
                    text += `直前に相手（${opponentStr}）は「${coord}」に打ちました。\n`;
                } else {
                    text += `ゲーム開始です。あなたが先手です。\n`;
                }
                text += `\n現在の盤面状況:\n` + generateAsciiBoard();
                text += `\n【履歴】\n`;
                text += getHistoryText();
                text += `\n\nあなたの番です。勝利のために最適な手を考え、座標（例: H8）だけで答えてください。`;
                text += `\n※ 座標は横軸アルファベット(A-O)、縦軸数字(1-15)です。`;
            }
        } else {
            // 英語プロンプト
             if (isGameOver) {
                const winner = currentPlayer === 1 ? 2 : 1; 
                const name = winner === 1 ? "Black" : "White";
                const lastMoveCoord = lastMove ? `${COL_LABELS[lastMove.c]}${lastMove.r + 1}` : "";
                text = `Game Over!\n${name} won by playing at ${lastMoveCoord}.\nGood game! Let's review the match.`;
            } else {
                text = `We are playing Gomoku (15x15 board).\nYou are "${playerStr}".\n`;
                if (lastMove) {
                    const coord = `${COL_LABELS[lastMove.c]}${lastMove.r + 1}`;
                    text += `The opponent (${opponentStr}) just played at "${coord}".\n`;
                } else {
                    text += `Game Start. You are the first player (Black).\n`;
                }
                text += `\nCurrent Board:\n` + generateAsciiBoard();
                text += `\n[History]\n`;
                text += getHistoryText();
                text += `\n\nIt's your turn. Think of the best move to win and reply with ONLY the coordinates (e.g., H8).`;
                text += `\n* Coordinates: Horizontal (A-O), Vertical (1-15).`;
            }
        }
        
        promptEl.value = text;
    }
    
    function getHistoryText() {
        let text = "";
        const historyLimit = 10;
        const startIdx = Math.max(0, moves.length - historyLimit);
        if (startIdx > 0) text += `... (Previous ${startIdx} moves omitted)\n`;
        for(let i=startIdx; i<moves.length; i++) {
            const m = moves[i];
            text += `${i+1}: ${m.player===1?"B":"W"}(${COL_LABELS[m.c]}${m.r+1}) `;
        }
        return text;
    }

    function generateAsciiBoard() {
        // 安全対策: boardが正しくない場合は空文字を返す
        if (!board || board.length === 0 || !board[0]) return "";

        let ascii = "   A B C D E F G H I J K L M N O\n";
        for (let r = 0; r < BOARD_SIZE; r++) {
            let rowStr = (r + 1).toString().padStart(2, ' ') + " ";
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (board[r][c] === 0) rowStr += ". ";
                else if (board[r][c] === 1) rowStr += "X ";
                else rowStr += "O ";
            }
            ascii += rowStr + "\n";
        }
        return ascii;
    }

    function copyPrompt() {
        const copyText = document.getElementById("aiPrompt");
        copyText.select();
        copyText.setSelectionRange(0, 99999);
        document.execCommand("copy");
        
        const btn = document.getElementById("copyBtn");
        const originalContent = btn.innerHTML;
        
        btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-green-600"><polyline points="20 6 9 17 4 12"/></svg>`;
        btn.classList.add("bg-green-50", "border-green-200");
        
        setTimeout(() => {
            btn.innerHTML = originalContent;
            btn.classList.remove("bg-green-50", "border-green-200");
        }, 1500);
    }

    function showModal(title, message, onConfirm, isAlert = false) {
        const t = translations[currentLang];
        modalTitleEl.textContent = title;
        modalMessageEl.textContent = message;
        
        if (isAlert) {
            modalCancelBtn.classList.add('hidden');
            modalOkBtn.textContent = t.modalOkAlert;
            modalOkBtn.onclick = closeModal;
        } else {
            modalCancelBtn.classList.remove('hidden');
            modalCancelBtn.textContent = t.modalCancel;
            modalOkBtn.textContent = t.modalOk;
            modalOkBtn.onclick = () => {
                if (onConfirm) onConfirm();
            };
        }
        modalEl.classList.remove('hidden');
        setTimeout(() => {
            modalEl.classList.remove('opacity-0');
            modalEl.querySelector('div').classList.remove('scale-95');
            modalEl.querySelector('div').classList.add('scale-100');
        }, 10);
    }

    function closeModal() {
        modalEl.classList.add('opacity-0');
        modalEl.querySelector('div').classList.remove('scale-100');
        modalEl.querySelector('div').classList.add('scale-95');
        setTimeout(() => {
            modalEl.classList.add('hidden');
        }, 200);
    }

    function showAlert(title, message) {
        showModal(title, message, null, true);
    }

    function confirmReset() {
        const t = translations[currentLang];
        showModal(t.modalConfirmTitle, t.msgResetConfirm, initGame, false);
    }
    
    function confirmStart() {
        const t = translations[currentLang];
        if (moves.length > 0) {
            showModal(t.modalConfirmTitle, t.msgStartConfirm, initGame, false);
        } else {
            initGame();
        }
    }

    // Initialize with default language
    setLanguage('ja');
    initGame();
}
</script>
</body>
</html>
